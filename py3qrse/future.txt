# class ABXQRSEKernel(AAQRSEKernel):
#     parameters = 'tb ts mb ms b xi'.split()
#     p_names_fancy =[r'$T_{buy}$', r'$T_{sell}$', r'$\mu_{buy}$', r'$\mu_{sell}$', r'$\beta$', r'$\xi']
#     actions = this.TERNARY_BASE_ACTIONS
#     name = "ABX-QRSE"
#     long_name = "Asymmetric-Behavior X QRSE"
#
#
#     def logits(self, x, params):
#         tb, ts, mb, ms, _ = params[:5]
#
#         e_buy = np.exp((x-mb)/tb)
#         e_sell = np.exp(-(x-ms)/ts)
#         e_hold = 1.
#
#         e_sum = e_buy + e_sell + e_hold
#
#         return e_buy/e_sum, e_sell/e_sum, e_hold/e_sum
#
#     def potential(self, x , params):
#         b, xi = params[-2:]
#         p_buy, p_sell, _ = self.logits(x, params)
#         return -b*(p_buy - p_sell)*(x-xi)
#
#     def entropy(self, x, params):
#         p_buy, p_sell, p_hold = self.logits(x, params)
#         return -p_buy*np.log(p_buy)-p_sell*np.log(p_sell)-p_hold*np.log(p_hold)
#
#     def log_kernel(self, x, params):
#         b, xi = params[-2:]
#         p_buy, p_sell, p_hold = self.logits(x, params)
#         potential = -b*(p_buy - p_sell)*(x-xi)
#         entropy = -p_buy*np.log(p_buy)-p_sell*np.log(p_sell)-p_hold*np.log(p_hold)
#         return potential + entropy
#
#     def set_params0(self, data, weights=None):
#         if data is not None:
#             mean, std = mean_std_fun(data, weights)
#         else:
#             mean, std =  self._mean, self._std
#         self.xi = mean
#         return np.array([std, std, mean, mean, 1/std, mean])
#
# class S3QRSEKernel(AAQRSEKernel):
#     parameters = 't k m b'
#
#     name = "S3-QRSE"
#     long_name = "3-State Symmetric QRSE"
#
#     def logits(self, x, params):
#         t, k, m, _ = params[:4]
#
#         mb = m+k
#         ms = m-k
#
#         e_buy = np.exp((x-mb)/t)
#         e_sell = np.exp(-(x-ms)/t)
#         e_hold = 1.
#
#         e_sum = e_buy + e_sell + e_hold
#
#         return e_buy/e_sum, e_sell/e_sum, e_hold/e_sum
#
# def set_params0(self, data, weights=None):
#         if data is not None:
#             mean, std = mean_std_fun(data, weights)
#         else:
#             mean, std =  self._mean, self._std
#         self.xi = mean
#         return np.array([std, std*.5, mean, 1/std])
#
#
# class ATQRSEKernel(AAQRSEKernel):
#         parameters = 'tb ts m b'.split()
#         p_names_fancy =[r'$T_{buy}$', r'$T_{sell}$', r'$\mu$', r'$\beta$']
#         actions = this.TERNARY_BASE_ACTIONS
#         name = "AT-QRSE"
#         long_name = "Asymmetric-Temperature QRSE"
#
#         def logits(self, x, params):
#             tb, ts, m,  = params[:3]
#
#             e_buy = np.exp((x-m)/tb)
#             e_sell = np.exp(-(x-m)/ts)
#             e_hold = 1.
#
#             e_sum = e_buy + e_sell + e_hold
#
#             return e_buy/e_sum, e_sell/e_sum, e_hold/e_sum
#
#         def set_params0(self, data, weights=None):
#             if data is not None:
#                 mean, std = mean_std_fun(data, weights)
#             else:
#                 mean, std =  self._mean, self._std
#             self.xi = mean
#             return np.array([std, std, mean, 1./std])
#
# class ALTBQRSEKernel(AAQRSEKernel):
#         parameters = 'tb ts m bb bs'.split()
#         p_names_fancy =[r'$T_{buy}$', r'$T_{sell}$', r'$\mu$', r'$\beta_{buy}$', r'$\beta_{sell}$']
#         actions = this.TERNARY_BASE_ACTIONS
#         name = "ALB-QRSE"
#         long_name = "Asymmetric-Liquidity-Temperature QRSE"
#
#         def logits(self, x, params):
#             tb, ts, m,  = params[:3]
#
#             e_buy = np.exp((x-m)/tb)
#             e_sell = np.exp(-(x-m)/ts)
#             e_hold = 1.
#
#             e_sum = e_buy + e_sell + e_hold
#
#             return e_buy/e_sum, e_sell/e_sum, e_hold/e_sum
#
#         def log_kernel(self, x, params):
#             bb, bs = params[-2:]
#             p_buy, p_sell, p_hold = self.logits(x, params)
#             potential = (-bb*p_buy + bs*p_sell)*(x-self.xi)
#             entropy = -p_buy*np.log(p_buy)-p_sell*np.log(p_sell)-p_hold*np.log(p_hold)
#             return potential + entropy
#
#         def set_params0(self, data, weights=None):
#             if data is not None:
#                 mean, std = mean_std_fun(data, weights)
#             else:
#                 mean, std =  self._mean, self._std
#             self.xi = mean
#             return np.array([std, std, mean, 1./std, 1./std])
#
# class ABMQRSEKernel(AAQRSEKernel):
#         parameters = 't mb bs bb bs'.split()
#         p_names_fancy =[r'$T$', r'$mu_{buy}$', r'$\mu_{sell}$', r'$\beta_{buy}$', r'$\beta_{sell}$']
#         actions = this.TERNARY_BASE_ACTIONS
#         name = "ALB-QRSE"
#         long_name = "Asymmetric-Liquidity-Temperature QRSE"
#
#         def logits(self, x, params):
#             t, mb, ms  = params[:3]
#
#             e_buy = np.exp((x-mb)/t)
#             e_sell = np.exp(-(x-ms)/t)
#             e_hold = 1.
#
#             e_sum = e_buy + e_sell + e_hold
#
#             return e_buy/e_sum, e_sell/e_sum, e_hold/e_sum
#
#         def log_kernel(self, x, params):
#             bb, bs = params[-2:]
#             p_buy, p_sell, p_hold = self.logits(x, params)
#             potential = (-bb*p_buy + bs*p_sell)*(x-self.xi)
#             entropy = -p_buy*np.log(p_buy)-p_sell*np.log(p_sell)-p_hold*np.log(p_hold)
#             return potential + entropy
#
#         def set_params0(self, data, weights=None):
#             if data is not None:
#                 mean, std = mean_std_fun(data, weights)
#             else:
#                 mean, std =  self._mean, self._std
#             self.xi = mean
#             p0s = np.array([std,  mean, mean, 1./std, 1./std])
#             return p0s
#
#
# class AAQRSEKernel3(AAQRSEKernel):
#         parameters = 't mb ms b'.split()
#         p_names_fancy =[r'$T$', r'$\mu_{buy}$', r'$\mu_{sell}$', r'$\beta$']
#         name = "AB-QRSE-3"
#         long_name = "Asymmetric-Behavior QRSE 3"
#
#         def logits(self, x, params):
#             t, mb, ms,  = params[:3]
#
#             e_buy = np.exp((x-mb)/t)
#             e_sell = np.exp(-(x-ms)/t)
#             e_hold = 1.
#
#             e_sum = e_buy + e_sell + e_hold
#
#             return e_buy/e_sum, e_sell/e_sum, e_hold/e_sum
#
#         def set_params0(self, data, weights=None):
#             if data is not None:
#                 mean, std = mean_std_fun(data, weights)
#             else:
#                 mean, std =  self._mean, self._std
#             self.xi = mean
#             return np.array([std, mean, mean, 1./std])
#
#
#
# class AQRSEKernel(AAQRSEKernel):
#     parameters = 'tb ts mb ms bb bs'.split()
#     p_names_fancy =[r'$T_{buy}$', r'$T_{sell}$', r'$\mu_{buy}$', r'$\mu_{sell}$', r'$\beta_{buy}$', r'$\beta_{sell}$']
#     name = "A-QRSE"
#     long_name = "Asymmetric QRSE"
#
#
#     def potential(self, x , params):
#         bb, bs = params[-2:]
#         p_buy, p_sell, _ = self.logits(x, params)
#         return (-bb*p_buy + bs*p_sell)*(x-self.xi)
#
#     def log_kernel(self, x, params):
#         bb, bs = params[-2:]
#         p_buy, p_sell, p_hold = self.logits(x, params)
#         potential = (-bb*p_buy + bs*p_sell)*(x-self.xi)
#         entropy = -p_buy*np.log(p_buy)-p_sell*np.log(p_sell)-p_hold*np.log(p_hold)
#         return potential + entropy
#
#     def set_params0(self, data, weights=None):
#         if data is not None:
#             mean, std = mean_std_fun(data, weights)
#         else:
#             mean, std =  self._mean, self._std
#         self.xi = mean
#         return np.array([std, std, mean+std/2., mean-std/2., 1./std, 1./std])
#
#
# class ABESEKernel(AAQRSEKernel):
#     parameters = 'tb ts mb ms b le'.split()
#     p_names_fancy =[r'$T_{buy}$', r'$T_{sell}$', r'$\mu_{buy}$', r'$\mu_{sell}$', r'$\beta$', r'$\lambda_{e}$']
#     name = "ABE-QRSE"
#     long_name = "Asymmetric Behavior Equilibrium QRSE"
#
#
#     def potential(self, x , params):
#         b, le = params[-2:]
#         p_buy, p_sell, _ = self.logits(x, params)
#         return -(p_buy - p_sell)*(b*(x-self.xi)+le)
#
#     def log_kernel(self, x, params):
#
#         return self.potential(x, params) + self.entropy(x, params)
#
#     def set_params0(self, data, weights=None):
#         if data is not None:
#             mean, std = mean_std_fun(data, weights)
#         else:
#             mean, std =  self._mean, self._std
#         self.xi = mean
#         return np.array([std, std, mean+std/2., mean-std/2., 1./std, 0.])


